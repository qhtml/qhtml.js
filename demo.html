<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,height=device-height, initial-scale=1.0">
    <title>QHTML Demo</title> 
    <script src="qhtml.js" type="text/javascript"></script> <!-- required for q-html parsing -->
	<script src="https://qhtml.github.io/qhtml.js/bs-tags.js" type="text/javascript"></script> <!-- optional w3-tags addon -->   
	    <script src="w3-tags.js" type="text/javascript"></script> <!-- optional w3-tags addon -->
	    <script src="tools/qhtml-tools.js" type="text/javascript"></script>
	    <script src="q-editor.js" type="text/javascript"></script>
	    <script src="codemirror/codemirror.js" type="text/javascript"></script> <!-- codemirror v6 bundle -->
    <link rel="stylesheet" href="codemirror/codemirror.css"> <!-- codemirror base styles -->
    <link rel="stylesheet" href="https://qhtml.github.io/qhtml.js/bs.css"> <!--  bs-tags.js dependency -->
	<link rel="stylesheet" href="w3.css"> <!--  w3-tags.js dependency -->
    <style>
    .w3-theme-l5 {
    color: #000 !important;
    background-color: #e8effa !important
}

.w3-theme-l4 {
    color: #000 !important;
    background-color: #b2cbed !important
}

.w3-theme-l3 {
    color: #fff !important;
    background-color: #6496dc !important
}

.w3-theme-l2 {
    color: #fff !important;
    background-color: #2a65b8 !important
}

.w3-theme-l1 {
    color: #fff !important;
    background-color: #183a6a !important
}

.w3-theme-d1 {
    color: #fff !important;
    background-color: #060e1a !important
}

.w3-theme-d2 {
    color: #fff !important;
    background-color: #050d17 !important
}

.w3-theme-d3 {
    color: #fff !important;
    background-color: #050b14 !important
}

.w3-theme-d4 {
    color: #fff !important;
    background-color: #040a11 !important
}

.w3-theme-d5 {
    color: #fff !important;
    background-color: #03080f !important
}

.w3-theme-bg {
    color: #fff !important;
    background-color: #07111f !important
}

.w3-theme-light {
    color: #000 !important;
    background-color: #e8effa !important
}

.w3-theme-dark {
    color: #fff !important;
    background-color: #03080f !important
}

.w3-theme-action {
    color: #fff !important;
    background-color: #03080f !important
}

.w3-theme {
    color: #fff !important;
    background-color: #07111f !important
}

.w3-text-theme {
    color: #07111f !important
}

.w3-border-theme {
    border-color: #07111f !important
}

.w3-hover-theme:hover {
    color: #fff !important;
    background-color: #07111f !important
}

.w3-hover-text-theme:hover {
    color: #07111f !important
}

.w3-hover-border-theme:hover {
    border-color: #07111f !important
}

        code-view:not(:defined) { display: none; }
        :root{
            --q-selector:#82aaff;
            --q-brace:#89ddff;
            --q-colon:#b0bec5;
            --q-semi:#b0bec5;
            --q-prop:#c3e88d;
            --q-value:#f8f8f2;
            --q-number:#f2ae49;
            --q-kw:#c792ea;
            --q-comma:#b0bec5;
            --q-comment:#5c6773;
            --q-embedded:#a0a0ff;
            --q-class: var(--hl-string);
            --hl-bg: #0f1220;
            --hl-fg: #e6e6e6;
            --hl-tag: #7aa2f7;
            --hl-angle: #89ddff;
            --hl-attr: #c3e88d;
            --hl-eq: #b0bec5;
            --hl-string: #f78c6c;
            --hl-comment: #5c6773;
            --hl-doctype: #ffcb6b;
            --hl-entity: #c792ea;
            --hl-text: #e6e6e6;
        }

        .qhtml-editor {
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            overflow: hidden;
            background: #fff;
        }
        .qhtml-tabs {
            display: flex;
            align-items: center;
            gap: 2px;
            background: #f8fafc;
            padding: 6px;
            flex-wrap: wrap;
        }
        .qhtml-tab {
            appearance: none;
            border: 0;
            background: transparent;
            padding: .5rem .75rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 300;
            color: #475569;
        }
        .qhtml-tab[aria-selected="true"] {
            background: #fff;
            box-shadow: 0 1px 0 #e5e7eb inset, 0 -1px 0 #fff inset;
            color: #111827;
        }
        .qhtml-toggle {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: .4rem;
            font-size: .75rem;
            color: #334155;
        }
        .qhtml-toggle input { accent-color: #2563eb; }
        .qhtml-panel { position: relative; display: none; }
        .qhtml-panel[data-active="true"] { display: block; }

        .qhtml-editor .cm-editor {
            background: var(--hl-bg);
            color: var(--hl-fg);
            min-height: 12rem;
        }
        .qhtml-editor .cm-content {
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
            font-size: 13px;
            line-height: 1.5;
            font-variant-ligatures: none;
            tab-size: 4;
        }
        .qhtml-editor .cm-scroller { padding: 1rem; }
        .qhtml-editor .cm-gutters {
            background: var(--hl-bg);
            color: #94a3b8;
            border: none;
        }
        .qhtml-editor .cm-activeLineGutter { background: rgba(255,255,255,0.06); }
        .qhtml-editor .cm-cursor,
        .qhtml-editor .cm-dropCursor { border-left-color: var(--hl-fg); }
        .qhtml-editor .cm-selectionBackground,
        .qhtml-editor .cm-content ::selection { background: rgba(255,255,255,0.25); }

        .cm-q-selector { color: var(--q-selector); }
        .cm-q-class { color: var(--q-class); }
        .cm-q-brace { color: var(--q-brace); }
        .cm-q-colon { color: var(--q-colon); }
        .cm-q-semi { color: var(--q-semi); }
        .cm-q-prop { color: var(--q-prop); }
        .cm-q-value { color: var(--q-value); }
        .cm-q-string { color: var(--hl-string); }
        .cm-q-number { color: var(--q-number); }
        .cm-q-kw { color: var(--q-kw); }
        .cm-q-comma { color: var(--q-comma); }
        .cm-q-comment { color: var(--q-comment); font-style: italic; }
        .cm-q-embedded { color: var(--q-embedded); }

        #qhtmlPreview {
            width: 100%;
            min-height: 12rem;
        }
    </style>
    <script>
        const HTML_VOID_TAGS = new Set([
            'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'
        ]);
        const HTML_PRESERVE_TEXT_TAGS = new Set(['pre', 'textarea', 'script', 'style']);

        function formatHTMLFallback(html) {
            if (!html) return '';
            const normalized = String(html).replace(/>\s+</g, '><').trim();
            const lines = normalized.replace(/></g, '>\n<').split('\n');
            let indent = 0;
            const pad = (n) => '  '.repeat(n);
            const out = [];
            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                const isClosing = /^<\/[A-Za-z]/.test(line);
                const isOpening = /^<[A-Za-z]/.test(line);
                const isSelfClosing = /\/>$/.test(line);
                const tagNameMatch = isOpening ? line.match(/^<([A-Za-z0-9:_-]+)/) : null;
                const tagName = tagNameMatch ? tagNameMatch[1].toLowerCase() : '';

                if (isClosing) indent = Math.max(0, indent - 1);
                out.push(pad(indent) + line);
                if (isOpening && !isClosing && !isSelfClosing && tagName && !HTML_VOID_TAGS.has(tagName)) {
                    indent += 1;
                }
            }
            return out.join('\n');
        }

        function stripQhtmlQuotedSections(line) {
            let result = '';
            let quote = '';
            let escaped = false;
            for (let i = 0; i < line.length; i++) {
                const ch = line[i];
                if (quote) {
                    if (escaped) {
                        escaped = false;
                        continue;
                    }
                    if (ch === '\\') {
                        escaped = true;
                        continue;
                    }
                    if (ch === quote) {
                        quote = '';
                    }
                    continue;
                }
                if (ch === '"' || ch === '\'' || ch === '`') {
                    quote = ch;
                    continue;
                }
                result += ch;
            }
            return result;
        }

        function countLeadingIndentChars(line) {
            let i = 0;
            while (i < line.length && (line[i] === ' ' || line[i] === '\t')) i += 1;
            return i;
        }

        function lineOffsets(lines) {
            const starts = [];
            let pos = 0;
            for (let i = 0; i < lines.length; i++) {
                starts.push(pos);
                pos += lines[i].length;
                if (i < lines.length - 1) pos += 1;
            }
            return starts;
        }

        function lineIndexAtOffset(starts, lines, offset) {
            let idx = 0;
            const totalLength = lines.join('\n').length;
            const clamped = Math.max(0, Math.min(offset, totalLength));
            while (idx + 1 < starts.length && starts[idx + 1] <= clamped) idx += 1;
            return idx;
        }

        function formatQhtmlForEditing(source, cursorStart, cursorEnd, protectRadius) {
            const raw = String(source || '').replace(/\r\n/g, '\n');
            if (!raw) {
                return {
                    text: '',
                    cursorStart: 0,
                    cursorEnd: 0
                };
            }

            const lines = raw.split('\n');
            const oldStarts = lineOffsets(lines);
            const protect = new Set();

            const safeStart = typeof cursorStart === 'number' ? cursorStart : null;
            const safeEnd = typeof cursorEnd === 'number' ? cursorEnd : safeStart;
            const radius = typeof protectRadius === 'number' ? Math.max(0, protectRadius) : 0;

            if (safeStart !== null && safeEnd !== null && lines.length) {
                const startLine = lineIndexAtOffset(oldStarts, lines, safeStart);
                const endLine = lineIndexAtOffset(oldStarts, lines, safeEnd);
                const lo = Math.max(0, Math.min(startLine, endLine) - radius);
                const hi = Math.min(lines.length - 1, Math.max(startLine, endLine) + radius);
                for (let i = lo; i <= hi; i++) protect.add(i);
            }

            const newLines = [];
            const oldLeading = [];
            const newLeading = [];
            let depth = 0;

            for (let idx = 0; idx < lines.length; idx++) {
                const originalLine = lines[idx];
                const trimmed = originalLine.trim();
                const oldLead = countLeadingIndentChars(originalLine);
                oldLeading[idx] = oldLead;

                if (!trimmed) {
                    newLines.push('');
                    newLeading[idx] = 0;
                    continue;
                }

                let leadingClosers = 0;
                while (leadingClosers < trimmed.length && trimmed[leadingClosers] === '}') {
                    leadingClosers += 1;
                }
                const targetDepth = Math.max(0, depth - leadingClosers);
                const desiredIndent = '  '.repeat(targetDepth);

                const content = originalLine.slice(oldLead);
                const keepAsTyped = protect.has(idx);
                const formattedLine = keepAsTyped ? originalLine : (desiredIndent + content);

                newLines.push(formattedLine);
                newLeading[idx] = keepAsTyped ? oldLead : desiredIndent.length;

                const analysisLine = stripQhtmlQuotedSections(trimmed).replace(/\/\/.*$/, '');
                const opens = (analysisLine.match(/\{/g) || []).length;
                const closes = (analysisLine.match(/\}/g) || []).length;
                depth = Math.max(0, depth + opens - closes);
            }

            const text = newLines.join('\n');
            const newStarts = lineOffsets(newLines);

            const mapOffset = (offset) => {
                if (typeof offset !== 'number') return 0;
                const oldTotal = raw.length;
                const clamped = Math.max(0, Math.min(offset, oldTotal));
                const lineIdx = lineIndexAtOffset(oldStarts, lines, clamped);
                const oldLineStart = oldStarts[lineIdx];
                const newLineStart = newStarts[lineIdx];
                const oldLine = lines[lineIdx] || '';
                const newLine = newLines[lineIdx] || '';
                const oldIndent = oldLeading[lineIdx] || 0;
                const newIndent = newLeading[lineIdx] || 0;
                const oldColumn = clamped - oldLineStart;

                let newColumn;
                if (oldColumn <= oldIndent) {
                    const deltaFromCodeStart = oldColumn - oldIndent;
                    newColumn = Math.max(0, newIndent + deltaFromCodeStart);
                } else {
                    newColumn = oldColumn + (newIndent - oldIndent);
                }

                newColumn = Math.max(0, Math.min(newColumn, newLine.length));
                return Math.max(0, Math.min(newLineStart + newColumn, text.length));
            };

            return {
                text,
                cursorStart: mapOffset(safeStart),
                cursorEnd: mapOffset(safeEnd)
            };
        }

        function formatQhtml(source) {
            return formatQhtmlForEditing(source, null, null, 0).text.trim();
        }

        function formatHTML(html) {
            const source = String(html || '').trim();
            if (!source) return '';
            if (typeof document === 'undefined') {
                return formatHTMLFallback(source);
            }

            try {
                const template = document.createElement('template');
                template.innerHTML = source;

                const lines = [];
                const pad = (n) => '  '.repeat(Math.max(0, n));
                const pushLine = (depth, text) => {
                    if (!text) return;
                    lines.push(pad(depth) + text);
                };

                const formatAttributes = (element) => {
                    const attrs = Array.from(element.attributes || []);
                    if (!attrs.length) return '';
                    return ' ' + attrs.map((attr) => {
                        const safeValue = String(attr.value || '').replace(/"/g, '&quot;');
                        return attr.name + '="' + safeValue + '"';
                    }).join(' ');
                };

                const walk = (node, depth, parentTag) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        const tag = node.tagName.toLowerCase();
                        const attrs = formatAttributes(node);

                        if (HTML_VOID_TAGS.has(tag)) {
                            pushLine(depth, '<' + tag + attrs + '>');
                            return;
                        }

                        const allChildren = Array.from(node.childNodes || []);
                        const children = allChildren.filter((child) => {
                            if (child.nodeType !== Node.TEXT_NODE) return true;
                            return !!String(child.nodeValue || '').replace(/\s+/g, ' ').trim();
                        });

                        if (!children.length) {
                            pushLine(depth, '<' + tag + attrs + '></' + tag + '>');
                            return;
                        }

                        const inlineTextOnly = children.length === 1
                            && children[0].nodeType === Node.TEXT_NODE
                            && !HTML_PRESERVE_TEXT_TAGS.has(tag);

                        if (inlineTextOnly) {
                            const text = String(children[0].nodeValue || '').replace(/\s+/g, ' ').trim();
                            pushLine(depth, '<' + tag + attrs + '>' + text + '</' + tag + '>');
                            return;
                        }

                        pushLine(depth, '<' + tag + attrs + '>');
                        children.forEach((child) => walk(child, depth + 1, tag));
                        pushLine(depth, '</' + tag + '>');
                        return;
                    }

                    if (node.nodeType === Node.TEXT_NODE) {
                        const rawText = String(node.nodeValue || '');
                        if (HTML_PRESERVE_TEXT_TAGS.has(parentTag || '')) {
                            rawText.replace(/\r\n/g, '\n').split('\n').forEach((textLine) => {
                                if (textLine.length) pushLine(depth, textLine);
                            });
                        } else {
                            const collapsed = rawText.replace(/\s+/g, ' ').trim();
                            if (collapsed) pushLine(depth, collapsed);
                        }
                        return;
                    }

                    if (node.nodeType === Node.COMMENT_NODE) {
                        const comment = String(node.nodeValue || '').trim();
                        if (comment) pushLine(depth, '<!-- ' + comment + ' -->');
                    }
                };

                Array.from(template.content.childNodes || []).forEach((node) => walk(node, 0, ''));
                return lines.join('\n').trim();
            } catch (err) {
                return formatHTMLFallback(source);
            }
        }

        function escapeHighlightHtml(value) {
            return String(value || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function renderHighlightTokens(tokens) {
            let out = '';
            for (const token of tokens) {
                const className = token.type ? 'tok-' + token.type : 'tok-text';
                if (token.raw === true) {
                    out += '<span class="' + className + '">' + token.value + '</span>';
                } else {
                    out += '<span class="' + className + '">' + escapeHighlightHtml(token.value) + '</span>';
                }
            }
            return out;
        }

        function tokenizeHtmlForHighlight(input) {
            const source = String(input || '');
            const tokens = [];
            let index = 0;
            const len = source.length;

            const push = (type, value) => {
                if (value) tokens.push({ type, value });
            };

            while (index < len) {
                if (source.startsWith('<!--', index)) {
                    const end = source.indexOf('-->', index + 4);
                    const stop = end === -1 ? len : end + 3;
                    push('comment', source.slice(index, stop));
                    index = stop;
                    continue;
                }

                if (source[index] === '<') {
                    if (source.startsWith('<!', index) && !source.startsWith('<!--', index)) {
                        const end = source.indexOf('>', index + 2);
                        const stop = end === -1 ? len : end + 1;
                        push('doctype', source.slice(index, stop));
                        index = stop;
                        continue;
                    }

                    const isClosing = source.startsWith('</', index);
                    push('angle', isClosing ? '</' : '<');
                    index += isClosing ? 2 : 1;

                    const nameMatch = /^[A-Za-z][A-Za-z0-9:_-]*/.exec(source.slice(index));
                    if (!nameMatch) {
                        push('text', source[index] || '');
                        index += 1;
                        continue;
                    }
                    push('tag', nameMatch[0]);
                    index += nameMatch[0].length;

                    while (index < len) {
                        if (source.startsWith('/>', index)) {
                            push('angle', '/>');
                            index += 2;
                            break;
                        }
                        if (source[index] === '>') {
                            push('angle', '>');
                            index += 1;
                            break;
                        }

                        const wsMatch = /^[\s]+/.exec(source.slice(index));
                        if (wsMatch) {
                            push('text', wsMatch[0]);
                            index += wsMatch[0].length;
                            continue;
                        }

                        const attrMatch = /^[^\s/>=]+/.exec(source.slice(index));
                        if (!attrMatch) {
                            push('text', source[index]);
                            index += 1;
                            continue;
                        }
                        push('attr', attrMatch[0]);
                        index += attrMatch[0].length;

                        const postNameWs = /^[\s]+/.exec(source.slice(index));
                        if (postNameWs) {
                            push('text', postNameWs[0]);
                            index += postNameWs[0].length;
                        }

                        if (source[index] === '=') {
                            push('eq', '=');
                            index += 1;

                            const postEqWs = /^[\s]+/.exec(source.slice(index));
                            if (postEqWs) {
                                push('text', postEqWs[0]);
                                index += postEqWs[0].length;
                            }

                            if (source[index] === '"' || source[index] === '\'') {
                                const quote = source[index];
                                let end = index + 1;
                                while (end < len && source[end] !== quote) {
                                    if (source[end] === '\\' && end + 1 < len) end += 2;
                                    else end += 1;
                                }
                                end = end < len ? end + 1 : len;
                                push('string', source.slice(index, end));
                                index = end;
                            } else {
                                const unquoted = /^[^\s>]+/.exec(source.slice(index));
                                if (unquoted) {
                                    push('string', unquoted[0]);
                                    index += unquoted[0].length;
                                }
                            }
                        }
                    }
                    continue;
                }

                if (source[index] === '&') {
                    const semi = source.indexOf(';', index + 1);
                    if (semi !== -1) {
                        push('entity', source.slice(index, semi + 1));
                        index = semi + 1;
                        continue;
                    }
                }

                const nextTag = source.indexOf('<', index);
                const nextEntity = source.indexOf('&', index);
                let stop = len;
                if (nextTag !== -1) stop = Math.min(stop, nextTag);
                if (nextEntity !== -1) stop = Math.min(stop, nextEntity);
                if (stop === index) stop += 1;
                push('text', source.slice(index, stop));
                index = stop;
            }

            return tokens;
        }

        function highlightHtmlCode(input) {
            return renderHighlightTokens(tokenizeHtmlForHighlight(input));
        }

        const QHTML_VENDOR_PREFIXES = ['w3-', 'bs-', 'uk-', 'mdc-'];
        const QHTML_KEYWORDS = new Set(['html', 'component', 'q-component', 'slot', 'into', 'q-import', 'bsl']);

        function tokenizeQhtmlForHighlight(input) {
            const source = String(input || '');
            const tokens = [];
            let index = 0;
            let depth = 0;

            const push = (type, value, raw) => {
                if (!value) return;
                tokens.push({ type, value, raw: raw === true });
            };

            const readQuoted = (quote) => {
                const start = index;
                index += 1;
                while (index < source.length) {
                    const ch = source[index];
                    index += 1;
                    if (ch === '\\' && index < source.length) {
                        index += 1;
                        continue;
                    }
                    if (ch === quote) break;
                }
                return source.slice(start, index);
            };

            while (index < source.length) {
                const ch = source[index];

                if (source.startsWith('//', index)) {
                    const end = source.indexOf('\n', index + 2);
                    const stop = end === -1 ? source.length : end;
                    push('q-comment', source.slice(index, stop));
                    index = stop;
                    continue;
                }

                if (source.startsWith('/*', index)) {
                    const end = source.indexOf('*/', index + 2);
                    const stop = end === -1 ? source.length : end + 2;
                    push('q-comment', source.slice(index, stop));
                    index = stop;
                    continue;
                }

                if (ch === '"' || ch === '\'' || ch === '`') {
                    push('q-string', readQuoted(ch));
                    continue;
                }

                if (/[0-9]/.test(ch)) {
                    const match = /^[0-9][0-9._]*/.exec(source.slice(index));
                    if (match) {
                        push('q-number', match[0]);
                        index += match[0].length;
                        continue;
                    }
                }

                if (ch === '{' || ch === '}') {
                    depth += ch === '{' ? 1 : -1;
                    depth = Math.max(depth, 0);
                    push('q-brace', ch);
                    index += 1;
                    continue;
                }
                if (ch === ':') { push('q-colon', ch); index += 1; continue; }
                if (ch === ';') { push('q-semi', ch); index += 1; continue; }
                if (ch === ',') { push('q-comma', ch); index += 1; continue; }

                const wsMatch = /^[\s]+/.exec(source.slice(index));
                if (wsMatch) {
                    push('q-value', wsMatch[0]);
                    index += wsMatch[0].length;
                    continue;
                }

                const identMatch = /^[A-Za-z_][A-Za-z0-9_.-]*/.exec(source.slice(index));
                if (identMatch) {
                    const ident = identMatch[0];
                    index += ident.length;

                    let lookahead = index;
                    while (lookahead < source.length && /\s/.test(source[lookahead])) lookahead += 1;
                    const next = source[lookahead] || '';

                    if (ident === 'html' && next === '{') {
                        push('q-kw', ident);
                        if (lookahead > index) {
                            push('q-value', source.slice(index, lookahead));
                        }
                        push('q-brace', '{');
                        depth += 1;
                        index = lookahead + 1;

                        const innerStart = index;
                        let innerDepth = 1;
                        while (index < source.length && innerDepth > 0) {
                            if (source[index] === '{') innerDepth += 1;
                            else if (source[index] === '}') innerDepth -= 1;
                            index += 1;
                        }
                        const innerEnd = innerDepth === 0 ? index - 1 : index;
                        const innerHtml = source.slice(innerStart, innerEnd);
                        if (innerHtml) {
                            push('q-embedded', highlightHtmlCode(innerHtml), true);
                        }
                        if (innerDepth === 0) {
                            push('q-brace', '}');
                            depth = Math.max(0, depth - 1);
                        }
                        continue;
                    }

                    if (QHTML_KEYWORDS.has(ident)) {
                        push('q-kw', ident);
                    } else if (QHTML_VENDOR_PREFIXES.some((prefix) => ident.startsWith(prefix))) {
                        push('q-class', ident);
                    } else if (next === ':') {
                        push('q-prop', ident);
                    } else if (next === '{' || next === ',') {
                        push('q-selector', ident);
                    } else {
                        push(depth > 0 ? 'q-value' : 'q-selector', ident);
                    }
                    continue;
                }

                push('q-value', ch);
                index += 1;
            }

            return tokens;
        }

        function highlightQhtmlCode(input) {
            return renderHighlightTokens(tokenizeQhtmlForHighlight(input));
        }

        class CodeView extends HTMLElement {
            constructor() {
                super();
                this._tabs = null;
                this._activeIdx = 0;
                this._qhtmlIdx = 0;
                this._htmlIdx = 1;
                this._qhtmlSource = '';
                this._htmlRaw = '';
                this._htmlOutput = '';
                this._compiledHtmlRaw = '';
                this._compiledHtml = '';
                this._showRenderedHtml = false;
                this._renderVersion = 0;
                this._previewSelector = this.getAttribute('data-preview') || '';
                this._previewTarget = null;
                this._previewHost = null;
                this._scratchQhtml = null;
                this._qhtmlFormatTimer = null;
                this._isAutoFormattingQhtml = false;
                this._mounted = false;
                this.attachShadow({ mode: 'open' });
            }

            connectedCallback() {
                if (this._mounted) return;
                this._mounted = true;

                this._tabs = this._readTabs();
                this._qhtmlIdx = this._findQhtmlTabIndex();
                this._htmlIdx = this._findHtmlTabIndex();
                this._activeIdx = this._qhtmlIdx;
                this._previewTarget = this._previewSelector ? document.querySelector(this._previewSelector) : null;

                const initialSource = this._tabs[this._qhtmlIdx] ? this._tabs[this._qhtmlIdx].raw : '';
                this.innerHTML = '';
                this._renderShell();
                this._cacheDomNodes();
                this._bindEvents();
                this._setActiveTab(this._qhtmlIdx);
                this.setQhtmlSource(initialSource);
            }

            disconnectedCallback() {
                this._mounted = false;
            }

            setQhtmlSource(text) {
                this._qhtmlSource = formatQhtml(text);
                if (this._qhtmlInput) this._qhtmlInput.value = this._qhtmlSource;
                this._updateQhtmlHighlight();
                this._updateOutputs();
            }

            getQhtmlSource() {
                return this._qhtmlSource;
            }

            _readTabs() {
                const tabNodes = Array.from(this.querySelectorAll('code-view-tab'));
                if (!tabNodes.length) {
                    const initialQhtml = this.getAttribute('initial-qhtml') || '';
                    return [
                        { idx: 0, label: 'QHTML', raw: initialQhtml },
                        { idx: 1, label: 'HTML', raw: '' }
                    ];
                }

                return tabNodes.map((node, index) => {
                    const idx = Number.parseInt(node.getAttribute('tab') || String(index), 10) || index;
                    const label = node.getAttribute('label') || (idx === 0 ? 'QHTML' : (idx === 1 ? 'HTML' : 'Tab ' + idx));
                    const raw = (node.textContent || '').trim();
                    return { idx, label, raw };
                });
            }

            _findQhtmlTabIndex() {
                const match = this._tabs.findIndex((tab) => String(tab.label || '').trim().toLowerCase().includes('qhtml'));
                return match >= 0 ? match : 0;
            }

            _findHtmlTabIndex() {
                const normalize = (tab) => String(tab.label || '').trim().toLowerCase();
                let match = this._tabs.findIndex((tab) => normalize(tab) === 'html');
                if (match < 0) {
                    match = this._tabs.findIndex((tab) => {
                        const label = normalize(tab);
                        return label.includes('html') && !label.includes('qhtml');
                    });
                }
                if (match < 0) match = Math.min(1, this._tabs.length - 1);
                if (match === this._qhtmlIdx && this._tabs.length > 1) match = this._qhtmlIdx === 0 ? 1 : 0;
                return match;
            }

            _renderShell() {
                const tabButtons = this._tabs.map((tab, index) => {
                    return '<button class="cv-tab" type="button" role="tab" data-idx="' + index + '" aria-selected="false">' + tab.label + '</button>';
                }).join('');

                const panelMarkup = this._tabs.map((tab, index) => {
                    const isQhtml = index === this._qhtmlIdx;
                    const isHtml = index === this._htmlIdx;
                    if (isQhtml) {
                        return (
                            '<section class="cv-panel" role="tabpanel" data-idx="' + index + '" aria-hidden="true">' +
                                '<button class="cv-copy" type="button" data-idx="' + index + '" title="Copy source">Copy</button>' +
                                '<div class="cv-editor-wrap">' +
                                    '<pre class="cv-qhtml-highlight" aria-hidden="true"></pre>' +
                                    '<textarea class="cv-qhtml-input" spellcheck="false"></textarea>' +
                                '</div>' +
                            '</section>'
                        );
                    }
                    if (isHtml) {
                        return (
                            '<section class="cv-panel" role="tabpanel" data-idx="' + index + '" aria-hidden="true">' +
                                '<button class="cv-copy" type="button" data-idx="' + index + '" title="Copy HTML">Copy</button>' +
                                '<pre class="cv-html-output"></pre>' +
                            '</section>'
                        );
                    }
                    return (
                        '<section class="cv-panel" role="tabpanel" data-idx="' + index + '" aria-hidden="true">' +
                            '<button class="cv-copy" type="button" data-idx="' + index + '" title="Copy tab">Copy</button>' +
                            '<pre class="cv-static-output" data-static-idx="' + index + '"></pre>' +
                        '</section>'
                    );
                }).join('');

                this.shadowRoot.innerHTML =
                    '<style>' +
                        ':host { display:block; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }' +
                        '.cv { border: 1px solid #e5e7eb; border-radius: 12px; overflow: hidden; background: #fff; }' +
                        '.cv-tabs { display:flex; align-items:center; gap:2px; background:#f8fafc; padding:6px; flex-wrap:wrap; }' +
                        '.cv-tab { appearance:none; border:0; background:transparent; padding:.5rem .75rem; border-radius:8px; cursor:pointer; font-weight:300; color:#475569; }' +
                        '.cv-tab[aria-selected="true"] { background:#fff; box-shadow: 0 1px 0 #e5e7eb inset, 0 -1px 0 #fff inset; color:#111827; }' +
                        '.cv-toggle { margin-left:auto; display:none; align-items:center; gap:.4rem; font-size:.75rem; color:#334155; }' +
                        '.cv-toggle input { accent-color:#2563eb; }' +
                        '.cv-body { background: var(--hl-bg); color: var(--hl-fg); }' +
                        '.cv-panel { position:relative; display:none; }' +
                        '.cv-panel[data-active="true"] { display:block; }' +
                        '.cv-copy { position:absolute; top:.6rem; right:.6rem; font-size:.675rem; background:#111827; color:#fff; border:0; border-radius:8px; padding:.35rem .6rem; cursor:pointer; z-index:2; }' +
                        '.cv-editor-wrap { position:relative; min-height:10rem; }' +
                        '.cv-qhtml-highlight, .cv-qhtml-input, .cv-html-output, .cv-static-output { box-sizing:border-box; width:100%; min-height:10rem; margin:0; padding:1rem; border:0; font:inherit; font-size:13px; line-height:1.5; font-variant-ligatures:none; tab-size:4; overflow:auto; white-space:pre; }' +
                        '.cv-qhtml-highlight { background: var(--hl-bg); color: var(--hl-fg); pointer-events:none; }' +
                        '.cv-qhtml-input { position:absolute; inset:0; background:transparent; color:transparent; caret-color:var(--hl-fg); resize:vertical; outline:none; }' +
                        '.cv-qhtml-input::selection { background: rgba(255,255,255,0.25); }' +
                        '.cv-html-output, .cv-static-output { background: var(--hl-bg); color: var(--hl-fg); white-space:pre; }' +
                        '.tok-q-selector{color:var(--q-selector)} .tok-q-class{color:var(--q-class)} .tok-q-brace{color:var(--q-brace)} .tok-q-colon{color:var(--q-colon)} .tok-q-semi{color:var(--q-semi)} .tok-q-prop{color:var(--q-prop)} .tok-q-value{color:var(--q-value)} .tok-q-string{color:var(--hl-string)} .tok-q-number{color:var(--q-number)} .tok-q-kw{color:var(--q-kw)} .tok-q-comma{color:var(--q-comma)} .tok-q-comment{color:var(--q-comment);font-style:italic} .tok-q-embedded{color:var(--q-embedded)}' +
                        '.tok-angle{color:var(--hl-angle)} .tok-tag{color:var(--hl-tag)} .tok-attr{color:var(--hl-attr)} .tok-eq{color:var(--hl-eq)} .tok-string{color:var(--hl-string)} .tok-comment{color:var(--hl-comment);font-style:italic} .tok-doctype{color:var(--hl-doctype)} .tok-entity{color:var(--hl-entity)} .tok-text{color:var(--hl-text)}' +
                    '</style>' +
                    '<div class="cv" part="container">' +
                        '<div class="cv-tabs" role="tablist" aria-label="Code tabs">' +
                            tabButtons +
                            '<label class="cv-toggle">' +
                                '<input class="cv-toggle-input" type="checkbox">' +
                                '<span>Rendered HTML</span>' +
                            '</label>' +
                        '</div>' +
                        '<div class="cv-body">' + panelMarkup + '</div>' +
                    '</div>';
            }

            _cacheDomNodes() {
                const root = this.shadowRoot;
                this._tabButtons = Array.from(root.querySelectorAll('.cv-tab'));
                this._panels = Array.from(root.querySelectorAll('.cv-panel'));
                this._copyButtons = Array.from(root.querySelectorAll('.cv-copy'));
                this._qhtmlInput = root.querySelector('.cv-qhtml-input');
                this._qhtmlHighlight = root.querySelector('.cv-qhtml-highlight');
                this._htmlOutputNode = root.querySelector('.cv-html-output');
                this._htmlToggle = root.querySelector('.cv-toggle');
                this._htmlToggleInput = root.querySelector('.cv-toggle-input');

                root.querySelectorAll('.cv-static-output').forEach((node) => {
                    const idx = Number.parseInt(node.getAttribute('data-static-idx'), 10);
                    const tab = this._tabs[idx];
                    if (tab) node.textContent = tab.raw || '';
                });
            }

            _bindEvents() {
                if (this._qhtmlInput) {
                    this._qhtmlInput.addEventListener('input', () => {
                        if (this._isAutoFormattingQhtml) return;
                        this._qhtmlSource = this._qhtmlInput.value || '';
                        this._updateQhtmlHighlight();
                        this._updateOutputs();
                        this._scheduleQhtmlAutoFormat();
                    });
                    this._qhtmlInput.addEventListener('scroll', () => {
                        this._syncQhtmlScroll();
                    });
                    this._qhtmlInput.addEventListener('blur', () => {
                        this._applyQhtmlAutoFormat();
                    });
                }

                if (this._htmlToggleInput) {
                    this._htmlToggleInput.addEventListener('change', () => {
                        this._showRenderedHtml = !!this._htmlToggleInput.checked;
                        this._updateHtmlTab();
                    });
                }

                this._tabButtons.forEach((button) => {
                    button.addEventListener('click', () => {
                        const idx = Number.parseInt(button.getAttribute('data-idx'), 10) || 0;
                        this._setActiveTab(idx);
                    });
                });

                this._copyButtons.forEach((button) => {
                    button.addEventListener('click', async () => {
                        const idx = Number.parseInt(button.getAttribute('data-idx'), 10) || 0;
                        await this._copyTab(idx, button);
                    });
                });
            }

            _setActiveTab(index) {
                this._activeIdx = index;
                this._tabButtons.forEach((button, idx) => {
                    button.setAttribute('aria-selected', idx === index ? 'true' : 'false');
                });
                this._panels.forEach((panel, idx) => {
                    const active = idx === index;
                    panel.setAttribute('data-active', active ? 'true' : 'false');
                    panel.setAttribute('aria-hidden', active ? 'false' : 'true');
                });
                if (this._htmlToggle) {
                    this._htmlToggle.style.display = index === this._htmlIdx ? 'flex' : 'none';
                }
            }

            async _copyTab(index, button) {
                let text = '';
                if (index === this._qhtmlIdx) {
                    text = this._qhtmlSource;
                } else if (index === this._htmlIdx) {
                    text = this._showRenderedHtml ? (this._compiledHtml || this._htmlOutput || '') : (this._htmlOutput || '');
                } else if (this._tabs[index]) {
                    text = this._tabs[index].raw || '';
                }

                try {
                    await navigator.clipboard.writeText(text);
                    button.textContent = 'Copied';
                } catch (err) {
                    button.textContent = 'Copy failed';
                }
                setTimeout(() => { button.textContent = 'Copy'; }, 1200);
            }

            _updateQhtmlHighlight() {
                if (!this._qhtmlHighlight) return;
                this._qhtmlHighlight.innerHTML = highlightQhtmlCode(this._qhtmlSource || '');
                this._syncQhtmlScroll();
            }

            _syncQhtmlScroll() {
                if (!this._qhtmlInput || !this._qhtmlHighlight) return;
                this._qhtmlHighlight.scrollTop = this._qhtmlInput.scrollTop;
                this._qhtmlHighlight.scrollLeft = this._qhtmlInput.scrollLeft;
            }

            _scheduleQhtmlAutoFormat() {
                if (this._qhtmlFormatTimer) clearTimeout(this._qhtmlFormatTimer);
                this._qhtmlFormatTimer = setTimeout(() => this._applyQhtmlAutoFormat(), 350);
            }

            _applyQhtmlAutoFormat() {
                if (!this._qhtmlInput) return;
                const current = this._qhtmlInput.value || '';
                const start = this._qhtmlInput.selectionStart;
                const end = this._qhtmlInput.selectionEnd;
                const result = formatQhtmlForEditing(current, start, end, 1);
                const formatted = result.text;
                if (!formatted || formatted === current) return;

                this._isAutoFormattingQhtml = true;
                this._qhtmlSource = formatted;
                this._qhtmlInput.value = formatted;
                this._updateQhtmlHighlight();
                this._updateOutputs();
                this._qhtmlInput.selectionStart = Math.min(result.cursorStart, formatted.length);
                this._qhtmlInput.selectionEnd = Math.min(result.cursorEnd, formatted.length);
                this._isAutoFormattingQhtml = false;
            }

            async _updateOutputs() {
                const source = this._qhtmlSource || '';
                const renderVersion = ++this._renderVersion;
                let htmlRaw = '';
                try {
                    htmlRaw = await renderHtmlFromQhtml(source, this._scratchQhtml);
                } catch (err) {
                    console.warn('code-view render failed:', err);
                }

                if (renderVersion !== this._renderVersion) return;

                this._htmlRaw = htmlRaw || '';
                this._htmlOutput = formatHTML(this._htmlRaw);
                this._updateHtmlTab();
                this._updatePreview(source);
            }

            _updateHtmlTab() {
                if (!this._htmlOutputNode) return;
                const text = this._showRenderedHtml ? (this._compiledHtml || this._htmlOutput || '') : (this._htmlOutput || '');
                this._htmlOutputNode.innerHTML = highlightHtmlCode(text);
            }

            _updatePreview(source) {
                if (!this._previewTarget && this._previewSelector) {
                    this._previewTarget = document.querySelector(this._previewSelector);
                }
                if (!this._previewTarget) return;

                if (!this._previewHost || !this._previewTarget.contains(this._previewHost)) {
                    this._previewTarget.innerHTML = '';
                    this._previewHost = document.createElement('q-html');
                    this._previewTarget.appendChild(this._previewHost);
                }

                this._previewHost.innerHTML = source;
                if (typeof this._previewHost.render === 'function') this._previewHost.render();
                this._refreshCompiledHtml();
            }

            _refreshCompiledHtml() {
                if (!this._previewHost) return;
                const schedule = window.requestAnimationFrame || function(cb) { setTimeout(cb, 0); };
                schedule(() => {
                    if (!this._previewHost) return;
                    const raw = this._previewHost.innerHTML || '';
                    this._compiledHtmlRaw = raw;
                    this._compiledHtml = formatHTML(raw);
                    this._updateHtmlTab();
                });
            }
        }

        if (!customElements.get('code-view')) customElements.define('code-view', CodeView);

        function buildQhtmlStreamLanguage(StreamLanguage) {
            const vendorPrefixes = ['w3-','bs-','uk-','mdc-'];
            return StreamLanguage.define({
                startState() {
                    return {
                        depth: 0,
                        inBlockComment: false,
                        inHtml: false,
                        htmlDepth: 0,
                        wantHtml: false
                    };
                },
                token(stream, state) {
                    if (state.inBlockComment) {
                        if (stream.skipTo('*/')) {
                            stream.match('*/');
                            state.inBlockComment = false;
                        } else {
                            stream.skipToEnd();
                        }
                        return 'comment';
                    }

                    if (state.inHtml) {
                        if (stream.skipTo('}')) {
                            const text = stream.current();
                            if (text) return 'special';
                        }
                        if (stream.eat('}')) {
                            state.depth = Math.max(0, state.depth - 1);
                            if (state.depth < state.htmlDepth) {
                                state.inHtml = false;
                            }
                            return 'bracket';
                        }
                        stream.skipToEnd();
                        return 'special';
                    }

                    if (stream.eatSpace()) return null;

                    if (stream.match('//')) {
                        stream.skipToEnd();
                        return 'comment';
                    }
                    if (stream.match('/*')) {
                        state.inBlockComment = true;
                        return 'comment';
                    }

                    if (stream.match(/"(?:[^\\"]|\\.)*"?/)) return 'string';
                    if (stream.match(/'(?:[^\\']|\\.)*'?/)) return 'string';
                    if (stream.match(/`(?:[^\\`]|\\.)*`?/)) return 'string';
                    if (stream.match(/[0-9][0-9._]*/)) return 'number';

                    if (stream.eat('{')) {
                        state.depth += 1;
                        if (state.wantHtml) {
                            state.inHtml = true;
                            state.htmlDepth = state.depth;
                            state.wantHtml = false;
                        }
                        return 'bracket';
                    }
                    if (stream.eat('}')) {
                        state.depth = Math.max(0, state.depth - 1);
                        if (state.inHtml && state.depth < state.htmlDepth) {
                            state.inHtml = false;
                        }
                        return 'bracket';
                    }
                    if (stream.eat(':')) return 'punctuation';
                    if (stream.eat(';')) return 'punctuation';
                    if (stream.eat(',')) return 'punctuation';

                    if (stream.match(/[A-Za-z_][A-Za-z0-9_.-]*/)) {
                        const word = stream.current();
                        if (word === 'html') {
                            state.wantHtml = true;
                            return 'keyword';
                        }
                        if (word === 'component' || word === 'slot' || word === 'bsl') {
                            return 'keyword';
                        }
                        if (vendorPrefixes.some((prefix) => word.startsWith(prefix))) {
                            return 'className';
                        }
                        if (state.depth > 0) {
                            const rest = stream.string.slice(stream.pos);
                            if (/^\s*:/.test(rest)) {
                                return 'propertyName';
                            }
                            if (/^\s*[{,]/.test(rest)) {
                                return 'variableName';
                            }
                            return 'atom';
                        }
                        return 'variableName';
                    }

                    stream.next();
                    return null;
                }
            });
        }

        function setCodeMirrorText(view, text) {
            if (!view) return;
            const current = view.state.doc.toString();
            if (current === text) return;
            view.dispatch({
                changes: { from: 0, to: current.length, insert: text }
            });
        }

        function getQhtmlToolsApi() {
            if (window.qhtmlTools && typeof window.qhtmlTools.toHTML === 'function') return window.qhtmlTools;
            if (window['qhtml-tools'] && typeof window['qhtml-tools'].toHTML === 'function') return window['qhtml-tools'];
            if (window.qhtml && typeof window.qhtml.toHTML === 'function') return window.qhtml;
            return null;
        }

        function removeNewBodyQHtmlNodes(beforeSet) {
            const nodes = document.querySelectorAll('body > q-html');
            nodes.forEach((node) => {
                if (!beforeSet.has(node)) node.remove();
            });
        }

        async function renderHtmlFromQhtml(source, scratch) {
            if (!source) return '';
            const qhtmlSource = source.trim().replace(/^\"|\"$/g, '');
            const toolsApi = getQhtmlToolsApi();
            if (toolsApi && typeof toolsApi.toHTML === 'function') {
                const before = new Set(Array.from(document.querySelectorAll('body > q-html')));
                try {
                    const html = await Promise.resolve(toolsApi.toHTML(qhtmlSource));
                    return html || '';
                } finally {
                    removeNewBodyQHtmlNodes(before);
                }
            }

            const scratchEl = scratch || document.createElement('q-html');
            if (typeof scratchEl.preprocess !== 'function' || typeof scratchEl.parseQHtml !== 'function') {
                return source;
            }
            const pre = scratchEl.preprocess(qhtmlSource);
            const html = scratchEl.parseQHtml(pre);
            const regex = /\"{1}([^\\\"]*)\"{1}/mg;
            return html.replace(regex, (match, p1) => '\"' + decodeURIComponent(p1) + '\"');
        }

        function initCodeMirrorDemo(initialText, attempt) {
            if (!window.CM) {
                console.warn('CodeMirror bundle not loaded.');
                return null;
            }

            const attemptCount = typeof attempt === 'number' ? attempt : 0;
            const editorHost = document.getElementById('qhtmlEditor');
            const htmlHost = document.getElementById('qhtmlHtmlView');
            const toggle = document.getElementById('qhtmlRenderedToggle');
            if (!editorHost || !htmlHost) {
                if (attemptCount < 10) {
                    const schedule = (window.requestAnimationFrame || function(cb){ setTimeout(cb, 50); });
                    schedule(() => initCodeMirrorDemo(initialText, attemptCount + 1));
                } else {
                    console.warn('CodeMirror hosts not ready.');
                }
                return null;
            }
            if (editorHost.querySelector('.cm-editor') || htmlHost.querySelector('.cm-editor')) {
                return null;
            }

            const cmState = window.CM['@codemirror/state'] || {};
            const cmView = window.CM['@codemirror/view'] || {};
            const cmLang = window.CM['@codemirror/language'] || {};
            const cmCommands = window.CM['@codemirror/commands'] || {};
            const cmCore = window.CM['codemirror'] || {};
            const cmHtml = window.CM['@codemirror/lang-html'] || {};
            const cmHighlight = window.CM['@lezer/highlight'] || {};

            const { EditorState } = cmState;
            const { EditorView, keymap, lineWrapping } = cmView;
            const baseSetup = cmCore.basicSetup || cmCore.minimalSetup;
            const { StreamLanguage, HighlightStyle, syntaxHighlighting } = cmLang;
            const { indentWithTab } = cmCommands;
            const { html } = cmHtml;
            const { tags } = cmHighlight;

            if (!EditorState || !EditorView) {
                console.warn('CodeMirror core modules missing.');
                return null;
            }

            const baseTheme = EditorView.theme ? EditorView.theme({
                '&': { backgroundColor: 'var(--hl-bg)', color: 'var(--hl-fg)' },
                '.cm-content': { caretColor: 'var(--hl-fg)' },
                '.cm-scroller': { overflow: 'auto' }
            }, { dark: true }) : null;

            const htmlStyles = [];
            if (tags && tags.tagName) htmlStyles.push({ tag: tags.tagName, color: 'var(--hl-tag)' });
            if (tags && tags.attributeName) htmlStyles.push({ tag: tags.attributeName, color: 'var(--hl-attr)' });
            if (tags && tags.string) htmlStyles.push({ tag: tags.string, color: 'var(--hl-string)' });
            if (tags && tags.comment) htmlStyles.push({ tag: tags.comment, color: 'var(--hl-comment)', fontStyle: 'italic' });
            if (tags && tags.documentMeta) htmlStyles.push({ tag: tags.documentMeta, color: 'var(--hl-doctype)' });
            if (tags && tags.processingInstruction) htmlStyles.push({ tag: tags.processingInstruction, color: 'var(--hl-doctype)' });
            if (tags && tags.punctuation) htmlStyles.push({ tag: tags.punctuation, color: 'var(--hl-angle)' });
            if (tags && tags.character) htmlStyles.push({ tag: tags.character, color: 'var(--hl-entity)' });
            const canHighlight = !!(HighlightStyle && syntaxHighlighting && tags);
            const htmlHighlight = canHighlight && htmlStyles.length ? syntaxHighlighting(HighlightStyle.define(htmlStyles)) : null;

            const qhtmlStyles = [];
            if (tags && tags.variableName) qhtmlStyles.push({ tag: tags.variableName, color: 'var(--q-selector)' });
            if (tags && tags.className) qhtmlStyles.push({ tag: tags.className, color: 'var(--q-class)' });
            if (tags && tags.propertyName) qhtmlStyles.push({ tag: tags.propertyName, color: 'var(--q-prop)' });
            if (tags && tags.keyword) qhtmlStyles.push({ tag: tags.keyword, color: 'var(--q-kw)' });
            if (tags && tags.string) qhtmlStyles.push({ tag: tags.string, color: 'var(--hl-string)' });
            if (tags && tags.number) qhtmlStyles.push({ tag: tags.number, color: 'var(--q-number)' });
            if (tags && tags.comment) qhtmlStyles.push({ tag: tags.comment, color: 'var(--q-comment)', fontStyle: 'italic' });
            if (tags && tags.atom) qhtmlStyles.push({ tag: tags.atom, color: 'var(--q-value)' });
            if (tags && tags.bracket) qhtmlStyles.push({ tag: tags.bracket, color: 'var(--q-brace)' });
            if (tags && tags.punctuation) qhtmlStyles.push({ tag: tags.punctuation, color: 'var(--q-colon)' });
            if (tags && tags.special) qhtmlStyles.push({ tag: tags.special, color: 'var(--q-embedded)' });
            const qhtmlHighlight = canHighlight && qhtmlStyles.length ? syntaxHighlighting(HighlightStyle.define(qhtmlStyles)) : null;

            const qhtmlLanguage = StreamLanguage ? buildQhtmlStreamLanguage(StreamLanguage) : null;

            const normalizedInitialText = formatQhtml(initialText || '');

            const state = {
                qhtmlView: null,
                htmlView: null,
                scratch: document.createElement('q-html'),
                previewHost: null,
                htmlRaw: '',
                compiledHtml: '',
                showRendered: false,
                renderVersion: 0,
                qhtmlFormatTimer: null,
                isAutoFormattingQhtml: false
            };

            const updateHtmlView = () => {
                const text = state.showRendered ? state.compiledHtml : state.htmlRaw;
                setCodeMirrorText(state.htmlView, text || '');
            };

            const updatePreview = (source) => {
                const previewTarget = document.getElementById('qhtmlPreview');
                if (!previewTarget) return;
                if (!state.previewHost || !previewTarget.contains(state.previewHost)) {
                    previewTarget.innerHTML = '';
                    state.previewHost = document.createElement('q-html');
                    previewTarget.appendChild(state.previewHost);
                }
                try {
                    state.previewHost.innerHTML = source;
                    if (typeof state.previewHost.render === 'function') {
                        state.previewHost.render();
                    }
                } catch (err) {
                    console.warn('Preview render failed:', err);
                }
                const schedule = (window.requestAnimationFrame || function(cb){ setTimeout(cb, 0); });
                schedule(() => {
                    if (!state.previewHost) return;
                    state.compiledHtml = formatHTML(state.previewHost.innerHTML || '');
                    updateHtmlView();
                });
            };

            const updateOutputs = async (source) => {
                const renderVersion = ++state.renderVersion;
                let htmlRaw = '';
                try {
                    htmlRaw = await renderHtmlFromQhtml(source, state.scratch);
                } catch (err) {
                    console.warn('QHTML parse failed:', err);
                }
                if (renderVersion !== state.renderVersion) {
                    return;
                }
                state.htmlRaw = formatHTML(htmlRaw);
                updatePreview(source);
                updateHtmlView();
            };

            const baseExtensions = Array.isArray(baseSetup)
                ? baseSetup.filter(Boolean)
                : (baseSetup ? [baseSetup] : []);
            const tabKeymap = keymap && indentWithTab ? keymap.of([indentWithTab]) : null;
            const scheduleQhtmlAutoFormat = () => {
                if (state.qhtmlFormatTimer) clearTimeout(state.qhtmlFormatTimer);
                state.qhtmlFormatTimer = setTimeout(() => {
                    if (!state.qhtmlView) return;
                    const current = state.qhtmlView.state.doc.toString();
                    const selection = state.qhtmlView.state.selection.main;
                    const result = formatQhtmlForEditing(current, selection.anchor, selection.head, 1);
                    const formatted = result.text;
                    if (!formatted || formatted === current) return;
                    const anchor = Math.min(result.cursorStart, formatted.length);
                    const head = Math.min(result.cursorEnd, formatted.length);

                    state.isAutoFormattingQhtml = true;
                    setCodeMirrorText(state.qhtmlView, formatted);
                    state.qhtmlView.dispatch({ selection: { anchor, head } });
                    state.isAutoFormattingQhtml = false;
                }, 350);
            };

            const applyQhtmlAutoFormat = () => {
                if (!state.qhtmlView) return;
                const current = state.qhtmlView.state.doc.toString();
                const selection = state.qhtmlView.state.selection.main;
                const result = formatQhtmlForEditing(current, selection.anchor, selection.head, 1);
                const formatted = result.text;
                if (!formatted || formatted === current) return;
                const anchor = Math.min(result.cursorStart, formatted.length);
                const head = Math.min(result.cursorEnd, formatted.length);

                state.isAutoFormattingQhtml = true;
                setCodeMirrorText(state.qhtmlView, formatted);
                state.qhtmlView.dispatch({ selection: { anchor, head } });
                state.isAutoFormattingQhtml = false;
            };

            const updateListener = EditorView.updateListener
                ? EditorView.updateListener.of((update) => {
                    if (update.docChanged) {
                        const source = update.state.doc.toString();
                        updateOutputs(source);
                        if (!state.isAutoFormattingQhtml) {
                            scheduleQhtmlAutoFormat();
                        }
                    }
                })
                : null;

            const qhtmlExtensions = []
                .concat(baseExtensions, [
                    lineWrapping,
                    baseTheme,
                    qhtmlLanguage,
                    qhtmlHighlight,
                    tabKeymap,
                    updateListener
                ])
                .filter(Boolean);

            const htmlLanguage = html ? html({ matchClosingTags: true }) : null;
            const readOnly = EditorState.readOnly ? EditorState.readOnly.of(true) : null;
            const nonEditable = EditorView.editable ? EditorView.editable.of(false) : null;
            const htmlExtensions = []
                .concat(baseExtensions, [
                    baseTheme,
                    htmlLanguage,
                    htmlHighlight,
                    readOnly,
                    nonEditable
                ])
                .filter(Boolean);

            state.qhtmlView = new EditorView({
                state: EditorState.create({
                    doc: normalizedInitialText,
                    extensions: qhtmlExtensions
                }),
                parent: editorHost
            });

            if (state.qhtmlView && state.qhtmlView.dom) {
                state.qhtmlView.dom.addEventListener('blur', () => {
                    applyQhtmlAutoFormat();
                }, true);
            }

            state.htmlView = new EditorView({
                state: EditorState.create({
                    doc: '',
                    extensions: htmlExtensions
                }),
                parent: htmlHost
            });

            const tabs = Array.from(document.querySelectorAll('.qhtml-tab'));
            const panels = Array.from(document.querySelectorAll('.qhtml-panel'));
            const setActiveTab = (name) => {
                tabs.forEach((tab) => {
                    const active = tab.getAttribute('data-tab') === name;
                    tab.setAttribute('aria-selected', active ? 'true' : 'false');
                });
                panels.forEach((panel) => {
                    const active = panel.getAttribute('data-panel') === name;
                    panel.setAttribute('data-active', active ? 'true' : 'false');
                    panel.setAttribute('aria-hidden', active ? 'false' : 'true');
                });
            };

            tabs.forEach((tab) => {
                tab.addEventListener('click', () => {
                    setActiveTab(tab.getAttribute('data-tab'));
                });
            });

            if (toggle) {
                state.showRendered = !!toggle.checked;
                toggle.addEventListener('change', () => {
                    state.showRendered = !!toggle.checked;
                    updateHtmlView();
                });
            }

            setActiveTab('qhtml');
            updateOutputs(normalizedInitialText);

            return state;
        }
    </script>

</head>
<body class="w3-theme">
    <!-- Sample usage of the q-html component to make the whole page -->

 <q-html>
 div {
     }
	div { id: "tab_Playground" class: " w3-margin"
               	w3-container {
	              class: "w3-container"
                      html { "This is a playground for testing qhtml" }
               	  }
		p { html { "Enter your qHTML Code below" } }
		q-editor {
			id: "playgroundEditor"
			class: "w3-card w3-theme-d2"
		}
	          
	  }
	div { 
		id: "tab_Download"
		class: "w3-margin w3-hide"
               	p {
	              class: "w3-container"
                      html { "Download from github" }
	 		br { }
	 		a {
				href: "https://www.github.com/mikeNickaloff/qhtml"
	 			html { Download }
	 		} 
               	  }
		 table { id: "maintable" class: "w3-table w3-border-blue w3-grey w3-striped w3-text-black w3-card"
			th {
			  html { "Column 1" }
			}
			th {
			  html { "Column 2" }
			}
			th {
			  html { "column3" }
			}
			tr {
				td { html { "asdf" } }
				td { html { "asdf" } }
				td { html { "asdf" } }
			}
			tr {
				td { html { "1234" } }
				td { html { "4567" } }
				td { html { "7890" } }
			}
			tr {
				td { html { "asdf" } }
				td { html { "asdf" } }
				td { html { "asdf" } }
			}
		}
	          button {
        	       class: "w3-btn w3-blue w3-margin"
			html { "Click Me!" }
			onclick: "openModal()"
        	  }
	  }
          div {
 		class: "w3-modal"
		id: "myModal"
                div {
		    id: "myModalContent"
		    class: "w3-modal-content w3-container w3-card w3-large w3-white w3-padding"
		    header {
			class: "w3-header w3-blue w3-bar w3-padding w3-border"
			html { "my dialog" }
		   }
		    article {
			id: "myModalMessage"
                        class: "w3-container w3-center w3-white w3-normal w3-padding w3-margin"
			html { "heres my dialog" }
			br {

			}
			br {

			}
			span {
				html { "and an extra span for kicks" }
			}
	            }
		    div {
			class: "w3-footer w3-blue w3-center w3-large w3-padding"
			button {
  				 class: "w3-btn w3-blue w3-margin"
		                 html { "Close" }
				 onclick: "closeModal()"
			}
		   }
		}
	   
        
}
    </q-html>


<style> 
	#myModalContent {
	}
	#myModalMessage {
		height: 30vh
	}

	textarea {
		min-height: 40vh
	}
</style>
<script>

/* modal dialog */

function openModal() {
	document.querySelector("#myModal").style.display = 'block'
}
function closeModal() {
	document.querySelector("#myModal").style.display = 'none'
}

// document.querySelector / document.querySelectorAll 
// convenience aliases not part of qhtml

function qOne(sel) { return document.querySelector(sel) }
function qAll(sel) { return document.querySelectorAll(sel) }

/* Tab handling */

// tranform DOM Element List into Javascript Array and map the result of func(element) for each element
// used only for tab switching not part of qhtml
function mapFunc(list, func) {
	var tmap = []
	list.forEach(function(tm) { tmap.push(tm) })
	return tmap.map(function(item) { return func(item) })
}

// hide all tabs except for tabName
function toggleTab(tabName) {
	var tabPages = mapFunc(qAll("a"), itm => ({ name: itm.innerText, tab: "#tab_" + itm.innerText }))
	tabPages.forEach(obj => { 
	     qOne(obj.tab).className = obj.name == tabName ? "w3-card w3-margin" : "w3-card w3-margin w3-hide"
	})
}

/* end of tabs handling */


/* Playground initial code
    triggers after qhtml has been parsed for main page
 */

document.addEventListener("QHTMLContentLoaded", function() {

//set the demo playground default code
	const demoSource = `
q-component nav-bar {
    w3-black,w3-center {       
    w3-bar-item,w3-btn,w3-hover-grey {  
	   slot { nav-items }
       }                   
    }
}
w3-bar, w3-black, w3-text-white, div {
   nav-bar {
     li { html { top-item 1 } }   
       li { html { top-item 2 } }    
       li { html { top-item 3 } }    
   }
}
w3-container, w3-large, w3-title {
    w3-header,w3-xlarge,w3-green,div {
        html { Hello world }
    }
}
w3-twothird,w3-article, w3-panel, w3-light-grey, blockquote {
      w3-justify,article {
            p { 
                html { Heres a great article about saying hello to the
                        world. only the way everybody else does it -- by
                        saying hello world... only in latin... okay can i type now hello               } }
      }
}
w3-quarter, w3-nav, w3-col, w3-right, w3-padding,div {
         w3-list,w3-block,ul {
               w3-bar {
                  w3-green {
                     w3-bar-item {
                          li { html { navigation } }
                      }
                    }
                  nav-bar { 
				  li { html { right-item 1 } }   
       li { html { right-item 2 } }    
       li { html { right-item 3 } }    
				  }
                }
           }
   }

`

// end of demo playground code

	const editor = document.getElementById("playgroundEditor")
	if (editor && typeof editor.setQhtmlSource === "function") {
		editor.setQhtmlSource(demoSource.trim())
	} else if (editor) {
		editor.textContent = demoSource.trim()
	}
})








</script>
</body>
</html>
